import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/* eslint-disable no-use-before-define */

/**
 * Factorio Item Browser API
 * This API provides access to the mod data of the Factorio Item Browser, including item details, recipe details as well as any translation available from the mods.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: bluepsyduck@gmx.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
var BASE_PATH = "https://api.factorio-item-browser.com".replace(/\/+$/, "");
/**
 *
 * @export
 */

export var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
/**
 *
 * @export
 */

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export var RequiredError = /*#__PURE__*/function (_Error) {
  _inherits(RequiredError, _Error);

  var _super = _createSuper(RequiredError);

  function RequiredError(field, msg) {
    var _this;

    _classCallCheck(this, RequiredError);

    _this = _super.call(this, msg);
    _this.name = "RequiredError";
    return _this;
  }

  return RequiredError;
}(Error);
/**
 * An error which occurred during handling the request.
 * @export
 */

/**
 * AuthorizationApi - fetch parameter creator
 * @export
 */
export var AuthorizationApiFetchParamCreator = function AuthorizationApiFetchParamCreator(configuration) {
  return {
    /**
     * This request is used to create an authorization token to be used in all other requests. Part of the authorization is an access key provided by the administrator, as well as the names of mods which should be enabled for the token. The token will last for about an hour. Whenever you encounter a 401 error in the other requests, re-authorize to get a new token.<br /> <br /> To get a first look into the API, you may use the \"demo\" access key. This key is restricted to base mod only, though.
     * @summary Authorizes the access to the API by specifying the mods.
     * @throws {RequiredError}
     */
    auth: function auth(uNKNOWNBASETYPE, options) {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling auth.');
      }

      var localVarPath = "/auth";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AuthorizationApi - factory function to inject configuration 
 * @export
 */
export var AuthorizationApi = function AuthorizationApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request is used to create an authorization token to be used in all other requests. Part of the authorization is an access key provided by the administrator, as well as the names of mods which should be enabled for the token. The token will last for about an hour. Whenever you encounter a 401 error in the other requests, re-authorize to get a new token.<br /> <br /> To get a first look into the API, you may use the \"demo\" access key. This key is restricted to base mod only, though.
     * @summary Authorizes the access to the API by specifying the mods.
     * @throws {RequiredError}
     */
    auth: function auth(uNKNOWNBASETYPE) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).auth(uNKNOWNBASETYPE, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * CombinationApi - fetch parameter creator
 * @export
 */

export var CombinationApiFetchParamCreator = function CombinationApiFetchParamCreator(configuration) {
  return {
    /**
     * This request will trigger a new export of the combination of mods specified in the authorization token to be exported from the Factorio game and imported into the database. This process will take some time. The current status of the process can be accessed through the /combination/status endpoint.
     * @summary Requests the combination of mods from the authorization token to be exported from the Factorio game.
     * @throws {RequiredError}
     */
    combinationExport: function combinationExport(authorization, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling combinationExport.');
      }

      var localVarPath = "/combination/export";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },

    /**
     * This request provides information on how far the export process has progressed to make the data of the mods available. If data is not available yet, the API will fall back to the Vanilla combination in all other requests.
     * @summary Provides the current status of data of the combination of mods from the authorization token.
     * @throws {RequiredError}
     */
    combinationStatus: function combinationStatus(authorization, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling combinationStatus.');
      }

      var localVarPath = "/combination/status";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * CombinationApi - factory function to inject configuration 
 * @export
 */
export var CombinationApi = function CombinationApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request will trigger a new export of the combination of mods specified in the authorization token to be exported from the Factorio game and imported into the database. This process will take some time. The current status of the process can be accessed through the /combination/status endpoint.
     * @summary Requests the combination of mods from the authorization token to be exported from the Factorio game.
     * @throws {RequiredError}
     */
    combinationExport: function combinationExport(authorization) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = CombinationApiFetchParamCreator(configuration).combinationExport(authorization, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },

    /**
     * This request provides information on how far the export process has progressed to make the data of the mods available. If data is not available yet, the API will fall back to the Vanilla combination in all other requests.
     * @summary Provides the current status of data of the combination of mods from the authorization token.
     * @throws {RequiredError}
     */
    combinationStatus: function combinationStatus(authorization) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = CombinationApiFetchParamCreator(configuration).combinationStatus(authorization, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * GenericApi - fetch parameter creator
 * @export
 */

export var GenericApiFetchParamCreator = function GenericApiFetchParamCreator(configuration) {
  return {
    /**
     * This request provides very basic information to items and recipes, like the translated labels and description. It will NOT provide any additional data like ingredients and products of recipes.
     * @summary Provides basic data to items and recipes.
     * @throws {RequiredError}
     */
    genericDetails: function genericDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling genericDetails.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling genericDetails.');
      }

      var localVarPath = "/generic/details";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },

    /**
     * This request will return the icon file in base64 encoding. The icons are always provided in PNG format. Make sure to cache the returned icons, and remember to clear the cache when the mods are changed. The response may contain types and names of entities not explicitely requested, but which have the same icon as one of the requested one.
     * @summary Provides the icon file contents to specific items and recipes.
     * @throws {RequiredError}
     */
    genericIcon: function genericIcon(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling genericIcon.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling genericIcon.');
      }

      var localVarPath = "/generic/icon";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * GenericApi - factory function to inject configuration 
 * @export
 */
export var GenericApi = function GenericApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request provides very basic information to items and recipes, like the translated labels and description. It will NOT provide any additional data like ingredients and products of recipes.
     * @summary Provides basic data to items and recipes.
     * @throws {RequiredError}
     */
    genericDetails: function genericDetails(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = GenericApiFetchParamCreator(configuration).genericDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },

    /**
     * This request will return the icon file in base64 encoding. The icons are always provided in PNG format. Make sure to cache the returned icons, and remember to clear the cache when the mods are changed. The response may contain types and names of entities not explicitely requested, but which have the same icon as one of the requested one.
     * @summary Provides the icon file contents to specific items and recipes.
     * @throws {RequiredError}
     */
    genericIcon: function genericIcon(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = GenericApiFetchParamCreator(configuration).genericIcon(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * ItemsApi - fetch parameter creator
 * @export
 */

export var ItemsApiFetchParamCreator = function ItemsApiFetchParamCreator(configuration) {
  return {
    /**
     * This request will return all recipes with a specific item as one of its ingredients. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
     * @summary Provides all recipes in which a specific item as an ingredient of.
     * @throws {RequiredError}
     */
    itemIngredient: function itemIngredient(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling itemIngredient.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling itemIngredient.');
      }

      var localVarPath = "/item/ingredient";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },

    /**
     * This request will return all recipes with a specific item as one of its products. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
     * @summary Provides all recipes which produce a specific item.
     * @throws {RequiredError}
     */
    itemProduct: function itemProduct(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling itemProduct.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling itemProduct.');
      }

      var localVarPath = "/item/product";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },

    /**
     * 
     * @summary Provides random items of the currently enabled mods.
     * @throws {RequiredError}
     */
    itemRandom: function itemRandom(authorization, acceptLanguage, uNKNOWNBASETYPE, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling itemRandom.');
      }

      var localVarPath = "/item/random";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ItemsApi - factory function to inject configuration 
 * @export
 */
export var ItemsApi = function ItemsApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request will return all recipes with a specific item as one of its ingredients. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
     * @summary Provides all recipes in which a specific item as an ingredient of.
     * @throws {RequiredError}
     */
    itemIngredient: function itemIngredient(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemIngredient(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },

    /**
     * This request will return all recipes with a specific item as one of its products. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
     * @summary Provides all recipes which produce a specific item.
     * @throws {RequiredError}
     */
    itemProduct: function itemProduct(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemProduct(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },

    /**
     * 
     * @summary Provides random items of the currently enabled mods.
     * @throws {RequiredError}
     */
    itemRandom: function itemRandom(authorization, acceptLanguage, uNKNOWNBASETYPE) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemRandom(authorization, acceptLanguage, uNKNOWNBASETYPE, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * ModsApi - fetch parameter creator
 * @export
 */

export var ModsApiFetchParamCreator = function ModsApiFetchParamCreator(configuration) {
  return {
    /**
     * This request will list all mods known to the browser, including whether they are enabled for the current token or not.
     * @summary Lists the mods available in the browser.
     * @throws {RequiredError}
     */
    modList: function modList(authorization, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling modList.');
      }

      var localVarPath = "/mod/list";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ModsApi - factory function to inject configuration 
 * @export
 */
export var ModsApi = function ModsApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request will list all mods known to the browser, including whether they are enabled for the current token or not.
     * @summary Lists the mods available in the browser.
     * @throws {RequiredError}
     */
    modList: function modList(authorization, acceptLanguage) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var localVarFetchArgs = ModsApiFetchParamCreator(configuration).modList(authorization, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * RecipesApi - fetch parameter creator
 * @export
 */

export var RecipesApiFetchParamCreator = function RecipesApiFetchParamCreator(configuration) {
  return {
    /**
     * This request will return all details to specific recipes. If the recipe has a normal and an expensive version, then both are returned. The order of the returned recipes must be assumed to be random.
     * @summary Returns the details of specific recipes, including the ingredients and products.
     * @throws {RequiredError}
     */
    recipeDetails: function recipeDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling recipeDetails.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling recipeDetails.');
      }

      var localVarPath = "/recipe/details";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },

    /**
     * This request will return all machines with their details which are able to craft the recipe specified in the request. If the recipe supports being crafted by hand, a machine named \"player\" will appear in the list. When present, the player will be at the very first position of the results.
     * @summary Returns the details of all machines able to craft the recipe.
     * @throws {RequiredError}
     */
    recipeMachines: function recipeMachines(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling recipeMachines.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling recipeMachines.');
      }

      var localVarPath = "/recipe/machines";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * RecipesApi - factory function to inject configuration 
 * @export
 */
export var RecipesApi = function RecipesApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * This request will return all details to specific recipes. If the recipe has a normal and an expensive version, then both are returned. The order of the returned recipes must be assumed to be random.
     * @summary Returns the details of specific recipes, including the ingredients and products.
     * @throws {RequiredError}
     */
    recipeDetails: function recipeDetails(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = RecipesApiFetchParamCreator(configuration).recipeDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },

    /**
     * This request will return all machines with their details which are able to craft the recipe specified in the request. If the recipe supports being crafted by hand, a machine named \"player\" will appear in the list. When present, the player will be at the very first position of the results.
     * @summary Returns the details of all machines able to craft the recipe.
     * @throws {RequiredError}
     */
    recipeMachines: function recipeMachines(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = RecipesApiFetchParamCreator(configuration).recipeMachines(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};
/**
 * SearchApi - fetch parameter creator
 * @export
 */

export var SearchApiFetchParamCreator = function SearchApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @summary Searches for items, recipes etc. using a query string.
     * @throws {RequiredError}
     */
    searchQuery: function searchQuery(authorization, uNKNOWNBASETYPE, acceptLanguage, options) {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling searchQuery.');
      } // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined


      if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
        throw new RequiredError('uNKNOWNBASETYPE', 'Required parameter uNKNOWNBASETYPE was null or undefined when calling searchQuery.');
      }

      var localVarPath = "/search/query";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {}; // authentication jwt required
      // http basic authentication required

      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = authorization;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = acceptLanguage;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof uNKNOWNBASETYPE !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : uNKNOWNBASETYPE || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SearchApi - factory function to inject configuration 
 * @export
 */
export var SearchApi = function SearchApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @summary Searches for items, recipes etc. using a query string.
     * @throws {RequiredError}
     */
    searchQuery: function searchQuery(authorization, uNKNOWNBASETYPE, acceptLanguage) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchQuery(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};