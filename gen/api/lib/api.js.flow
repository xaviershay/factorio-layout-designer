// @flow
/* eslint-disable no-use-before-define */
/**
 * Factorio Item Browser API
 * This API provides access to the mod data of the Factorio Item Browser, including item details, recipe details as well as any translation available from the mods.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: bluepsyduck@gmx.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.factorio-item-browser.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}


/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * An error which occurred during handling the request.
 * @export
 */
export type Error = {
    /**
     * The message of the error which occurred.
     * @type {string}
     * @memberof Error
     */
    message?: string;
}



            export type ExportJobStatusEnum = 'queued' | 'downloading' | 'processing' | 'uploading' | 'uploaded' | 'done' | 'error';
/**
 * The information to an actual export job.
 * @export
 */
export type ExportJob = {
    /**
     * The current status of the export process.
     * @type {string}
     * @memberof ExportJob
     */
    status?: ExportJobStatusEnum;
    /**
     * The time when the export was triggered and put into the queue.
     * @type {string}
     * @memberof ExportJob
     */
    creationTime?: string;
    /**
     * The time when the actual export was processed.
     * @type {string}
     * @memberof ExportJob
     */
    exportTime?: string;
    /**
     * The time when the exported data has been imported to the browser database.
     * @type {string}
     * @memberof ExportJob
     */
    importTime?: string;
    /**
     * The error message in case the status is \"error\".
     * @type {string}
     * @memberof ExportJob
     */
    errorMessage?: string;
}



            export type GenericEntityTypeEnum = 'fluid' | 'item' | 'recipe';
/**
 * A generic entity with basic information.
 * @export
 */
export type GenericEntity = {
    /**
     * The type of the entity
     * @type {string}
     * @memberof GenericEntity
     */
    type?: GenericEntityTypeEnum;
    /**
     * The internal name of the entity.
     * @type {string}
     * @memberof GenericEntity
     */
    name?: string;
    /**
     * The translated label of the entity.
     * @type {string}
     * @memberof GenericEntity
     */
    label?: string;
    /**
     * The translated description of the entity.
     * @type {string}
     * @memberof GenericEntity
     */
    description?: string;
}


/**
 * A generic entity with basic information, including recipes.
 * @export
 */
export type GenericEntityWithRecipes = {
    /**
     * The recipes related to the entity.
     * @type {Array<RecipeWithExpensiveVersion>}
     * @memberof GenericEntityWithRecipes
     */
    recipes?: Array<RecipeWithExpensiveVersion>;
    /**
     * The total number of recipes available for the entity.
     * @type {number}
     * @memberof GenericEntityWithRecipes
     */
    totalNumberOfRecipes?: number;
} & GenericEntity


/**
 * 
 * @export
 */
export type GenericEntityWithRecipesAllOf = {
    /**
     * The recipes related to the entity.
     * @type {Array<RecipeWithExpensiveVersion>}
     * @memberof GenericEntityWithRecipesAllOf
     */
    recipes?: Array<RecipeWithExpensiveVersion>;
    /**
     * The total number of recipes available for the entity.
     * @type {number}
     * @memberof GenericEntityWithRecipesAllOf
     */
    totalNumberOfRecipes?: number;
}


/**
 * An icon of an item or recipe.
 * @export
 */
export type Icon = {
    /**
     * The entities using the icon file with the current enabled mods.
     * @type {Array<IconEntities>}
     * @memberof Icon
     */
    entities?: Array<IconEntities>;
    /**
     * The base64 encoded contents of the icon file.
     * @type {string}
     * @memberof Icon
     */
    content?: string;
    /**
     * The size of the icon in pixels.
     * @type {number}
     * @memberof Icon
     */
    size?: number;
}


/**
 * 
 * @export
 */
export type IconEntities = {
    /**
     * The type of the entity using this icon.
     * @type {string}
     * @memberof IconEntities
     */
    type?: string;
    /**
     * The name of the entity using this icon.
     * @type {string}
     * @memberof IconEntities
     */
    name?: string;
}



            export type ItemTypeEnum = 'fluid' | 'item';
/**
 * An actual item or fluid.
 * @export
 */
export type Item = {
    /**
     * The type of the item.
     * @type {string}
     * @memberof Item
     */
    type?: ItemTypeEnum;
    /**
     * The name of the item.
     * @type {string}
     * @memberof Item
     */
    name?: string;
    /**
     * The translated label of the item.
     * @type {string}
     * @memberof Item
     */
    label?: string;
    /**
     * The translated description of the item, if available.
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * The amount of the item as ingredient or product.
     * @type {number}
     * @memberof Item
     */
    amount?: number;
}



            export type MachineEnergyUsageUnitEnum = 'W' | 'kW' | 'MW' | 'GW' | 'TW' | 'PW' | 'EW' | 'ZW' | 'YW';
/**
 * A machine required to craft recipes.
 * @export
 */
export type Machine = {
    /**
     * The name of the machine.
     * @type {string}
     * @memberof Machine
     */
    name?: string;
    /**
     * The translated label of the machine.
     * @type {string}
     * @memberof Machine
     */
    label?: string;
    /**
     * The translated description of the machine, if available.
     * @type {string}
     * @memberof Machine
     */
    description?: string;
    /**
     * The crafting speed of the machine.
     * @type {number}
     * @memberof Machine
     */
    craftingSpeed?: number;
    /**
     * The number of ingredient slots available in the machine, or 255 if unlimited.
     * @type {number}
     * @memberof Machine
     */
    numberOfItemSlots?: number;
    /**
     * The number of fluid input slots available in the machine.
     * @type {number}
     * @memberof Machine
     */
    numberOfFluidInputSlots?: number;
    /**
     * The number of fluid output slots available in the machine.
     * @type {number}
     * @memberof Machine
     */
    numberOfFluidOutputSlots?: number;
    /**
     * The number of module slots available in the machine.
     * @type {number}
     * @memberof Machine
     */
    numberOfModuleSlots?: number;
    /**
     * The energy usage of the machine.
     * @type {number}
     * @memberof Machine
     */
    energyUsage?: number;
    /**
     * The unit of the energy usage.
     * @type {string}
     * @memberof Machine
     */
    energyUsageUnit?: MachineEnergyUsageUnitEnum;
}


/**
 * A mod supported by the API.
 * @export
 */
export type Mod = {
    /**
     * The internal name of the mod.
     * @type {string}
     * @memberof Mod
     */
    name?: string;
    /**
     * The translated label of the mod.
     * @type {string}
     * @memberof Mod
     */
    label?: string;
    /**
     * The translated description of the mod.
     * @type {string}
     * @memberof Mod
     */
    description?: string;
    /**
     * The author of the mod.
     * @type {string}
     * @memberof Mod
     */
    author?: string;
    /**
     * The version of the mod.
     * @type {string}
     * @memberof Mod
     */
    version?: string;
}



            export type RecipeModeEnum = 'normal' | 'expensive';
/**
 * A recipe to craft items into other ones.
 * @export
 */
export type Recipe = {
    /**
     * The name of the recipe.
     * @type {string}
     * @memberof Recipe
     */
    name?: string;
    /**
     * The mode of the recipe.
     * @type {string}
     * @memberof Recipe
     */
    mode?: RecipeModeEnum;
    /**
     * The translated label of the recipe.
     * @type {string}
     * @memberof Recipe
     */
    label?: string;
    /**
     * The translated description of the recipe, if available.
     * @type {string}
     * @memberof Recipe
     */
    description?: string;
    /**
     * The ingredients of the recipe.
     * @type {Array<Item>}
     * @memberof Recipe
     */
    ingredients?: Array<Item>;
    /**
     * The products of the recipe.
     * @type {Array<Item>}
     * @memberof Recipe
     */
    products?: Array<Item>;
    /**
     * The crafting time of the recipe.
     * @type {number}
     * @memberof Recipe
     */
    craftingTime?: number;
}


/**
 * A recipe to craft items into other ones, including an expensive version of it, if existing.
 * @export
 */
export type RecipeWithExpensiveVersion = {
    /**
     * 
     * @type {Recipe}
     * @memberof RecipeWithExpensiveVersion
     */
    expensiveVersion?: Recipe;
} & Recipe


/**
 * 
 * @export
 */
export type RecipeWithExpensiveVersionAllOf = {
    /**
     * 
     * @type {Recipe}
     * @memberof RecipeWithExpensiveVersionAllOf
     */
    expensiveVersion?: Recipe;
}




/**
 * AuthorizationApi - fetch parameter creator
 * @export
 */
export const AuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request is used to create an authorization token to be used in all other requests. Part of the authorization is an access key provided by the administrator, as well as the names of mods which should be enabled for the token. The token will last for about an hour. Whenever you encounter a 401 error in the other requests, re-authorize to get a new token.<br /> <br /> To get a first look into the API, you may use the \"demo\" access key. This key is restricted to base mod only, though.
         * @summary Authorizes the access to the API by specifying the mods.
         * @throws {RequiredError}
         */
        auth(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options: RequestOptions): FetchArgs {
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling auth.');
            }
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AuthorizationApiType = { 
    auth(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: RequestOptions): Promise<Object>,
}

/**
 * AuthorizationApi - factory function to inject configuration 
 * @export
 */
export const AuthorizationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AuthorizationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request is used to create an authorization token to be used in all other requests. Part of the authorization is an access key provided by the administrator, as well as the names of mods which should be enabled for the token. The token will last for about an hour. Whenever you encounter a 401 error in the other requests, re-authorize to get a new token.<br /> <br /> To get a first look into the API, you may use the \"demo\" access key. This key is restricted to base mod only, though.
         * @summary Authorizes the access to the API by specifying the mods.
         * @throws {RequiredError}
         */
        auth(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).auth(uNKNOWNBASETYPE, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * CombinationApi - fetch parameter creator
 * @export
 */
export const CombinationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will trigger a new export of the combination of mods specified in the authorization token to be exported from the Factorio game and imported into the database. This process will take some time. The current status of the process can be accessed through the /combination/status endpoint.
         * @summary Requests the combination of mods from the authorization token to be exported from the Factorio game.
         * @throws {RequiredError}
         */
        combinationExport(authorization: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling combinationExport.');
            }
            const localVarPath = `/combination/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request provides information on how far the export process has progressed to make the data of the mods available. If data is not available yet, the API will fall back to the Vanilla combination in all other requests.
         * @summary Provides the current status of data of the combination of mods from the authorization token.
         * @throws {RequiredError}
         */
        combinationStatus(authorization: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling combinationStatus.');
            }
            const localVarPath = `/combination/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CombinationApiType = { 
    combinationExport(authorization: string, options?: RequestOptions): Promise<Object>,

    combinationStatus(authorization: string, options?: RequestOptions): Promise<Object>,
}

/**
 * CombinationApi - factory function to inject configuration 
 * @export
 */
export const CombinationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CombinationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request will trigger a new export of the combination of mods specified in the authorization token to be exported from the Factorio game and imported into the database. This process will take some time. The current status of the process can be accessed through the /combination/status endpoint.
         * @summary Requests the combination of mods from the authorization token to be exported from the Factorio game.
         * @throws {RequiredError}
         */
        combinationExport(authorization: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = CombinationApiFetchParamCreator(configuration).combinationExport(authorization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This request provides information on how far the export process has progressed to make the data of the mods available. If data is not available yet, the API will fall back to the Vanilla combination in all other requests.
         * @summary Provides the current status of data of the combination of mods from the authorization token.
         * @throws {RequiredError}
         */
        combinationStatus(authorization: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = CombinationApiFetchParamCreator(configuration).combinationStatus(authorization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * GenericApi - fetch parameter creator
 * @export
 */
export const GenericApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request provides very basic information to items and recipes, like the translated labels and description. It will NOT provide any additional data like ingredients and products of recipes.
         * @summary Provides basic data to items and recipes.
         * @throws {RequiredError}
         */
        genericDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling genericDetails.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling genericDetails.');
            }
            const localVarPath = `/generic/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will return the icon file in base64 encoding. The icons are always provided in PNG format. Make sure to cache the returned icons, and remember to clear the cache when the mods are changed. The response may contain types and names of entities not explicitely requested, but which have the same icon as one of the requested one.
         * @summary Provides the icon file contents to specific items and recipes.
         * @throws {RequiredError}
         */
        genericIcon(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling genericIcon.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling genericIcon.');
            }
            const localVarPath = `/generic/icon`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GenericApiType = { 
    genericDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,

    genericIcon(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,
}

/**
 * GenericApi - factory function to inject configuration 
 * @export
 */
export const GenericApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GenericApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request provides very basic information to items and recipes, like the translated labels and description. It will NOT provide any additional data like ingredients and products of recipes.
         * @summary Provides basic data to items and recipes.
         * @throws {RequiredError}
         */
        genericDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = GenericApiFetchParamCreator(configuration).genericDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This request will return the icon file in base64 encoding. The icons are always provided in PNG format. Make sure to cache the returned icons, and remember to clear the cache when the mods are changed. The response may contain types and names of entities not explicitely requested, but which have the same icon as one of the requested one.
         * @summary Provides the icon file contents to specific items and recipes.
         * @throws {RequiredError}
         */
        genericIcon(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = GenericApiFetchParamCreator(configuration).genericIcon(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ItemsApi - fetch parameter creator
 * @export
 */
export const ItemsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will return all recipes with a specific item as one of its ingredients. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
         * @summary Provides all recipes in which a specific item as an ingredient of.
         * @throws {RequiredError}
         */
        itemIngredient(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling itemIngredient.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling itemIngredient.');
            }
            const localVarPath = `/item/ingredient`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will return all recipes with a specific item as one of its products. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
         * @summary Provides all recipes which produce a specific item.
         * @throws {RequiredError}
         */
        itemProduct(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling itemProduct.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling itemProduct.');
            }
            const localVarPath = `/item/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides random items of the currently enabled mods.
         * @throws {RequiredError}
         */
        itemRandom(authorization: string, acceptLanguage?: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling itemRandom.');
            }
            const localVarPath = `/item/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ItemsApiType = { 
    itemIngredient(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,

    itemProduct(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,

    itemRandom(authorization: string, acceptLanguage?: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: RequestOptions): Promise<Object>,
}

/**
 * ItemsApi - factory function to inject configuration 
 * @export
 */
export const ItemsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ItemsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request will return all recipes with a specific item as one of its ingredients. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
         * @summary Provides all recipes in which a specific item as an ingredient of.
         * @throws {RequiredError}
         */
        itemIngredient(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemIngredient(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This request will return all recipes with a specific item as one of its products. The recipes in the response will be grouped together by their name, so that normal and expensive versions will always be returned together, if both are available. The parameters \"numberOfResults\" and \"indexOfFirstResult\" are applied to these groups, not on the recipes itself.
         * @summary Provides all recipes which produce a specific item.
         * @throws {RequiredError}
         */
        itemProduct(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemProduct(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Provides random items of the currently enabled mods.
         * @throws {RequiredError}
         */
        itemRandom(authorization: string, acceptLanguage?: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemRandom(authorization, acceptLanguage, uNKNOWNBASETYPE, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ModsApi - fetch parameter creator
 * @export
 */
export const ModsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will list all mods known to the browser, including whether they are enabled for the current token or not.
         * @summary Lists the mods available in the browser.
         * @throws {RequiredError}
         */
        modList(authorization: string, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling modList.');
            }
            const localVarPath = `/mod/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModsApiType = { 
    modList(authorization: string, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,
}

/**
 * ModsApi - factory function to inject configuration 
 * @export
 */
export const ModsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request will list all mods known to the browser, including whether they are enabled for the current token or not.
         * @summary Lists the mods available in the browser.
         * @throws {RequiredError}
         */
        modList(authorization: string, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ModsApiFetchParamCreator(configuration).modList(authorization, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * RecipesApi - fetch parameter creator
 * @export
 */
export const RecipesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will return all details to specific recipes. If the recipe has a normal and an expensive version, then both are returned. The order of the returned recipes must be assumed to be random.
         * @summary Returns the details of specific recipes, including the ingredients and products.
         * @throws {RequiredError}
         */
        recipeDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling recipeDetails.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling recipeDetails.');
            }
            const localVarPath = `/recipe/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will return all machines with their details which are able to craft the recipe specified in the request. If the recipe supports being crafted by hand, a machine named \"player\" will appear in the list. When present, the player will be at the very first position of the results.
         * @summary Returns the details of all machines able to craft the recipe.
         * @throws {RequiredError}
         */
        recipeMachines(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling recipeMachines.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling recipeMachines.');
            }
            const localVarPath = `/recipe/machines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RecipesApiType = { 
    recipeDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,

    recipeMachines(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,
}

/**
 * RecipesApi - factory function to inject configuration 
 * @export
 */
export const RecipesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RecipesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This request will return all details to specific recipes. If the recipe has a normal and an expensive version, then both are returned. The order of the returned recipes must be assumed to be random.
         * @summary Returns the details of specific recipes, including the ingredients and products.
         * @throws {RequiredError}
         */
        recipeDetails(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = RecipesApiFetchParamCreator(configuration).recipeDetails(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This request will return all machines with their details which are able to craft the recipe specified in the request. If the recipe supports being crafted by hand, a machine named \"player\" will appear in the list. When present, the player will be at the very first position of the results.
         * @summary Returns the details of all machines able to craft the recipe.
         * @throws {RequiredError}
         */
        recipeMachines(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = RecipesApiFetchParamCreator(configuration).recipeMachines(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Searches for items, recipes etc. using a query string.
         * @throws {RequiredError}
         */
        searchQuery(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling searchQuery.');
            }
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            if (uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined) {
                throw new RequiredError('uNKNOWNBASETYPE','Required parameter uNKNOWNBASETYPE was null or undefined when calling searchQuery.');
            }
            const localVarPath = `/search/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication jwt required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = ((acceptLanguage:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof uNKNOWNBASETYPE !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uNKNOWNBASETYPE != null ? uNKNOWNBASETYPE : {}) : (((uNKNOWNBASETYPE:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SearchApiType = { 
    searchQuery(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions): Promise<Object>,
}

/**
 * SearchApi - factory function to inject configuration 
 * @export
 */
export const SearchApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SearchApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Searches for items, recipes etc. using a query string.
         * @throws {RequiredError}
         */
        searchQuery(authorization: string, uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, acceptLanguage?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchQuery(authorization, uNKNOWNBASETYPE, acceptLanguage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

export type ApiTypes = { 
    AuthorizationApi: AuthorizationApiType,

    CombinationApi: CombinationApiType,

    GenericApi: GenericApiType,

    ItemsApi: ItemsApiType,

    ModsApi: ModsApiType,

    RecipesApi: RecipesApiType,

    SearchApi: SearchApiType,
 }
